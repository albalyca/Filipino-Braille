import cv2
import numpy as np
import math
import os
import matplotlib.pyplot as plt
from skimage.feature import hog
from skimage.transform import resize

path = 'testing\IMG_4367 - bl (7).JPG'
original_image = cv2.imread(path, cv2.IMREAD_GRAYSCALE)  # Read image in grayscale
plt.imshow(original_image, cmap='gray')
plt.show()

# gaussian blur
blurred = cv2.GaussianBlur(original_image, (7,7), 0)
# otsu threshold
actual_thresh = np.max(original_image)/2
threshold = math.ceil(actual_thresh)
otsu_tv, otsu_thresh = cv2.threshold(blurred, threshold, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)
# inverted image
inverted_otsu = ~otsu_thresh
# fill in small areas of ones (removing noise)
min_ones_area = 400
# find connected components in the binary image
num_labels, labels, stats, centroids = cv2.connectedComponentsWithStats(inverted_otsu)
# iterate over each connected component (excluding background label)
for label in range(1, num_labels):
    if stats[label, cv2.CC_STAT_AREA] < min_ones_area:
        inverted_otsu[labels == label] = 0
# finding circles in the image and concatenating them
contours, _ = cv2.findContours(inverted_otsu, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
concatenated = np.concatenate(contours)
x, y, w, h = cv2.boundingRect(concatenated)
# cropping the image
cv2.rectangle(original_image, (x, y), (x + w - 1, y + h - 1), 255, 2)
cropped = inverted_otsu[y:y+h, x:x+w]
# resizing the image to 64 x 128
resized = resize(cropped, (64, 128))
resized *= 255  # convert pixel values back to [0, 255] range
resized = resized.astype(np.uint8)  # convert data type to uint8
processed_image = resized
img_resized = cv2.resize(processed_image, (128, 64))

# Compute HOG features
fd, hog_image = hog(img_resized, orientations=9, pixels_per_cell=(8, 8),
                    cells_per_block=(2, 2), visualize=True)

# Reshape the feature vector to match the input format during training
fd_reshaped = fd.reshape(1, -1)
predicted_class_index = np.argmax([svc.predict(fd_reshaped) for svc in svm_classifiers])
predicted_class = Classifications[predicted_class_index]
print("The predicted image is : " + predicted_class)
label = predicted_class
audio_output = gTTS(text = label, lang = 'tl', slow = False)
audio_output.save("audio_output.mp3")
os.system("start audio_output.mp3")
